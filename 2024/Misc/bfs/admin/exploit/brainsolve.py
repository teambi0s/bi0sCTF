#!/bin/python3 

from pwn import *

procc = "./brainf_ck.py"

procc = ["nc","localhost","1337"]

# SHORTHANDS FOR FNCS
def se(nbytes)      : return p.send(nbytes)
def sl(nbytes)      : return p.sendline(nbytes)
def sa(msg,nbytes)  : return p.sendafter(msg,nbytes)
def sla(msg,nbytes) : return p.sendlineafter(msg,nbytes)
def rv(nbytes)      : return p.recv(nbytes)
def rvu(msg)        : return p.recvuntil(msg)
def rvl()           : return p.recvline()
def w(msg)          : return print(f"▕〔\033[1;32m>\033[0m〕 {msg}")
# _____________________________________________________ #
# <<<<<<<<<<<<<<< EXPLOIT STARTS HERE >>>>>>>>>>>>>>>>> #

'''
----------------------------------------------------------------
    LEVEL - 1
----------------------------------------------------------------
PART 1 
TRAVELLING TO NONZERO
1 -[+[<+<]>-]>             [OPTIMIZED TO 12 BYTES]
PART 2
TRANSPORTING A BYTE CONSIDERING ANCHOR POINTS
2 [-<< +[-<+]- <+>> +[->+]- >]
2 [<[<<]>[<+>-]<]          [OPTIMIZED TO 15 BYTES]

ATTEMPT 1 
>->->-[<+[>>>+<<]>>-]<-<<+<<->[-<<+[-<+]-<+>>+[->+]->]

ATTEMPT 2 
<->-[+[<+<]>-]>[<[<<]>[<+>-]<]

ATTEMPT 3 - LEAK USING DP POSITION
<->-[+[<+<]>-]>-[[<+>-]<-]<

----------------------------------------------------------------
    LEVEL - 2
----------------------------------------------------------------
TRAVEL TO FIRST NON ZERO BYTE
1 -[+[<+<]>-]>
MARK THE BYTE AND DECREMENT IT UNTIL ZERO
2 .[-]

----------------------------------------------------------------
    LEVEL - 3
----------------------------------------------------------------
TRAVEL TO THE FIRST NON ZERO BYTE
1 -[+[<+<]>-]>
BRING THE BYTE BACK TO DP -5
2 [<[<<]>[<+>-]<]
DIVIDE IT BY N 
3 >>>+[<[<+>-]<[->+>[>-<-]>[<+<<<]>]>>>>+<<]>>-<<<<<<<+>
MOVE THE DP AS MUCH AS THE RESULT + SET NEXT TO ZERO ALONG THE WAY
[>[-]<[->+]-]

'''

flaglen1 = 19
flaglen2 = 19
flaglen3 = 19

p = process(procc)

flag = ""
#
#  LEVEL 1 SOLUTION 
#

sla(b"Your choice : ",b"N")
sla(b"Your choice : ",b"N")

for i in range (flaglen1):
    rvu(b"OF TAPE > [")
    fbyte = int(rvu(b"]")[:-1:])
    w(f"FLAG BYTE GOT AT {fbyte}")
    rvu(b"AT : ")
    dp = int(rvl().strip())
    w(f"DP CURRENTLY AT {dp}")
    if(dp < fbyte):
        sla(b"CODE : ",b"<->-[+[<+<]>-]>[<[<<]>[<+>-]<]")
    else:
        sla(b"CODE : ",b">-<-[+[>+>]<-]<[>[>>]<[>+<-]>]")
    rvu(b"ONE BYTE -- [")
    flag += chr(int(rvl()[:-2:]))
    w(f"FLAG = {flag}")
    print("---------------------------------")

#
#   LEVEL 2 SOLUTION 
#

def lvl2():
    global flaglen2,flaglen1
    sla(b"Your choice : ",b"N")
    sla(b"Your choice : ",b"N")
    for i in range (flaglen1):
        rvu(b"CODE : ")
        sl(b"")

    maps = {}
    dp   = 0

    sla(b"Your choice : ",b"N")
    rvu(b"ORDER -")
    for i in range (flaglen2):
        rvu(b"[")
        num = int(rvu(b"]")[:-1:])
        maps[num] = i

    mapp = sorted([i for i in maps])
    w(f"{mapp} {maps}")

    rvu(b"AT : ")
    dp = int(rvl().strip())
    w(f"DP IS AT {dp}")

    rvu(b"CODE : ")

    dpp = 0
    for i in range (len(mapp)):
        if(mapp[i]>dp):
            mapp.insert(i,dp)
            dpp = i
            break

    w(f"DPP AT {dpp}")

    count = 0
    payload = b""
    for i in maps:
        idx = mapp.index(i)
        di = (idx - dpp)
        if(di >= 0):
            p0 = b"-[+[<+<]>-]>>"
            p1 = b"<.[-]"
        else:
            p0 = b"-[+[>+>]<-]<<"
            p1 = b">.[-]"
        for _ in range (abs(di)):
            payload += p0
        payload += p1
        mapp.remove(mapp[dpp])
        dpp = mapp.index(i)
        count += 1

    sl(payload)
    rvu(b"-> ")
    return (rvu(b"<-")[:-3:]).decode()

#
#   LEVEL 3 SOLUTION
#

DIVISOR = 1
REMAINDER = 0

flagnums = []

def operatelvl3(pr3,pl3,off1,p3pt2,off2,p3pt3,type=DIVISOR):
    global flagnums,flag,flaglen3
    for i in range (flaglen3):
        rvu(b"EX OF TAPE > [")
        flagbyt = int(rvl()[:-2:])
        rvu(b"ALLY BE AT [")
        dp      = int(rvl()[:-2:])
        rvu(b"CODE :")
        if(flagbyt > dp):
            sl((pr3 + off1 + p3pt2 + off2 + p3pt3).encode())
        else:
            sl((pl3 + off1 + p3pt2 + off2 + p3pt3).encode())
            print(len(pl3 + off1 + p3pt2 + off2 + p3pt3))
        if(i < 9): stuff = p.recvuntil(b"?",timeout=10)
        else : continue
        if(type == DIVISOR):
            flagnums.append((stuff.count(b'|') + 4) * 10)
            # print("THIS IS THE FLAG MAIN ",(stuff.count(b'|') + 4) * 10)
        else:
            if(stuff.count(b'|') == 0):
                flagnums[i] += 10
                # print("THIS IS THE FLAG MOD ",stuff.count(b'|'))
            else:
                flagnums[i] +=  stuff.count(b'|')  - 1
            flag += chr(flagnums[i])
            w(f"BYTE OBTAINED - {flag}")
        w(f"FINISHED ITER {i}")
        print("---------------------------")

pr3 = "<<<<<<<->-[+[<+<]>-]>[<[<<]>[<+>-]<]>>+> <+<"
pl3 = "<<<<<-<-[+[>+>]<-]<[>[>>]<[->+<]>]<<+< <+<"
off1 = "++++++++++"
off2 = "-----"
p3pt2 = ">[<[<+>-]<[->>[<+>>-<-]>[<+<<<]>]>>>>+<<]>>-<<<<<<<[-]<+ "
p3pt3 = "[[->+<]>-]"

context.log_level = 'DEBUG'
p = process(procc)
flag += lvl2()
w(f"FLAG = {flag}")
print("---------------------------")
operatelvl3(pr3,pl3,off1,p3pt2,off2,p3pt3,type=DIVISOR)

pr3 = "<<<<<<<->-[+[<+<]>-]>[<[<<]>[<+>-]<]>>+> <+<"
pl3 = "<<<<<-<-[+[>+>]<-]<[>[>>]<[->+<]>]<<+< <+<"
off2 = ""
p3pt2 = ">[<[<+>-]<[->>[<+>>-<-]>[<+<<<]>]>>>>+<<]>>-<<<<<<<[-]<[-]<<<[->>>+<<<]>>>"

p = process(procc)
lvl2()
operatelvl3(pr3,pl3,off1,p3pt2,off2,p3pt3,type=REMAINDER)

w(flag)
print("---------------------------")
