

# This file was *autogenerated* from the file solver.sage
from sage.all_cmdline import *   # import sage library

_sage_const_44 = Integer(44); _sage_const_2 = Integer(2); _sage_const_0xBAD2C0DE = Integer(0xBAD2C0DE); _sage_const_0x6969 = Integer(0x6969); _sage_const_1 = Integer(1); _sage_const_91 = Integer(91); _sage_const_439336960671443073145803863477 = Integer(439336960671443073145803863477); _sage_const_0 = Integer(0); _sage_const_88 = Integer(88); _sage_const_176 = Integer(176)#solve script for the challenge
# implementing Merkleâ€“Hellman knapsack cryptosystem
from Crypto.Util.number import *
import fpylll
FLAG_FORMAT = "bi0s"


FLAG_FORMAT = "bi0s"

NBITS = _sage_const_44 <<_sage_const_2 

a = _sage_const_0xBAD2C0DE 
c = _sage_const_0x6969 
m = _sage_const_1 <<NBITS

public = [_sage_const_1 ]
for i in range(_sage_const_2 , _sage_const_91 ):
    public.append(public[-_sage_const_1 ]*i)
q = sum(public)

ct = eval(open('ct.txt').read())

public = [_sage_const_1 ]
for i in range(_sage_const_2 , _sage_const_91 ):
    public.append(public[-_sage_const_1 ]*i)
q = sum(public)
r = _sage_const_439336960671443073145803863477 

B = [r*i % q for i in public]

def decrypt(ct):
    r_inv = inverse(r, q)
    ct_inv = ct*r_inv % q
    lst = []
    while True:
        for i in range(len(public)-_sage_const_1 , -_sage_const_1 , -_sage_const_1 ):
            if ct_inv >= public[i]:
                ct_inv -= public[i]
                lst.append(i)
                break
        if ct_inv == _sage_const_0 :
            break
    d = {}
    for i in lst:
        if i in d:
            d[i] += _sage_const_1 
        else:
            d[i] = _sage_const_1 
    cct = _sage_const_0 
    # first item in the dict
    m = max(lst)
    for i, j in d.items():
        cct += _sage_const_2 **(m-i)*j
    return cct

ptlist = []
for i,j in ct:
    i = int(i)
    j = Integer(j)
    pt = decrypt(j)
    if pt.nbits() < i:
        pt = pt << (i-pt.nbits())
    ptlist.append(pt)
    
#Applying LCG on ptlist:
#load('solvelinmod.py')
def solve_linear_mod(equations, bounds, guesses=None):
    vars = list(bounds)
    if guesses is None:
        guesses = {}

    NR = len(equations)
    NV = len(vars)
    B = fpylll.IntegerMatrix(NR+NV, NR+NV)
    Y = [None] * (NR + NV)
    nS = _sage_const_1 
    for var in vars:
        nS = max(nS, int(bounds[var]).bit_length())
    S = (_sage_const_1  << (nS + (NR + NV + _sage_const_1 )))
    scales = {}
    for vi, var in enumerate(vars):
        scale = S >> (int(bounds[var]).bit_length())
        scales[var] = scale
        B[NR + vi, vi] = scale
        Y[NR + vi] = guesses.get(var, int(bounds[var]) >> _sage_const_1 ) * scale
    for ri, (rel, m) in enumerate(equations):
        op = rel.operator()
        if op is not operator.eq:
            raise TypeError('relation %s: not an equality relation' % rel)

        expr = (rel - rel.rhs()).lhs().expand()
        for var in expr.variables():
            if var not in bounds:
                raise ValueError('relation %s: variable %s is not bounded' % (rel, var))
        coeffs = []
        for vi, var in enumerate(vars):
            if expr.degree(var) >= _sage_const_2 :
                raise ValueError('relation %s: equation is not linear in %s' % (rel, var))
            coeff = expr.coefficient(var)
            if not coeff.is_constant():
                raise ValueError('relation %s: coefficient of %s is not constant (equation is not linear)' % (rel, var))
            if not coeff.is_integer():
                raise ValueError('relation %s: coefficient of %s is not an integer' % (rel, var))

            B[ri, vi] = (int(coeff) % m) * S
        B[ri, NV + ri] = m * S

        const = expr.subs({var: _sage_const_0  for var in vars})
        if not const.is_constant():
            raise ValueError('relation %s: failed to extract constant' % rel)
        if not const.is_integer():
            raise ValueError('relation %s: constant is not integer' % rel)
        Y[ri] = (int(-const) % m) * S
    Bt = B.transpose()
    lll = fpylll.LLL.reduction(Bt)
    result = fpylll.CVP.closest_vector(Bt, Y)
    if list(map(int, result[:NR])) != list(map(int, Y[:NR])):
        raise ValueError("CVP returned an incorrect result: input %s, output %s (try increasing your bounds?)" % (Y, result))

    res = {}
    for vi, var in enumerate(vars):
        aa = result[NR + vi] // scales[var]
        bb = result[NR + vi] % scales[var]
        if bb:
            warnings.warn("CVP returned suspicious result: %s=%d is not scaled correctly (try adjusting your bounds?)" % (var, result[NR + vi]))
        res[var] = aa

    return res

ciphertext = ptlist
equations = []
s = var('s')
ks = [var(f"k{i}") for i in range(len(FLAG_FORMAT))]
bounds = {k: _sage_const_2 **_sage_const_88  for k in ks}
bounds[s] = _sage_const_2 **_sage_const_176 

for i, (l, k) in enumerate(zip(FLAG_FORMAT, ks)):
    s = (s*a+c) 
    equations.append(((ciphertext[i] ^ i ^ ord(l)) << _sage_const_88  == s - k, m))

s = var('s')
seed = solve_linear_mod(equations, bounds)[s]
print("recovered seed =", seed)

plaintext = []
state = seed
for i, f in enumerate(ciphertext):
    state = (state*a+c) % m
    plaintext.append(chr((state >> (NBITS >> _sage_const_1 )) ^ i ^ f))
print("".join(plaintext))

