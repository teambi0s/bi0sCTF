# Leaky DSA Writeup

## Description

This challenge is warmup for Crypto ;)

## Solution

From chall.sage, we see that we're given the opportunity to send two inputs to the server, and the server will return two signatures. We can then use the leaky DSA attack to recover the private key.

We know that priv = (s*k-z)*r^-1. So we get two sets of these values, and construct a bivariate polynomial to solve for the missing bits of k. 

```python
from pwn import remote
io = remote('localhost',1337)
io.sendlineafter(b"Enter message: ", b"a")
z1, r1, s1, k1 = eval(io.recvline())
io.sendlineafter(b"Enter message: ", b"b")
z2, r2, s2, k2 = eval(io.recvline())
```

We sign two random messages and get respective values from the server. We then construct the polynomial and solve for the missing bits of k1 and k2. `x` and `y` are the missing bits of `k1` and `k2` respectively.

```python
PR.<x, y> = PolynomialRing(Zmod(q), 2)
f = (s1*(k1+x)-z1) * pow(r1, -1, q) - (s2*(k2+y)-z2) * pow(r2, -1, q) 
x, y = small_roots(f, bounds=(2**120, 2**120), m=1, d=4)[0]
```

The small_roots function works by computing the Groebner basis of the ideal that's generated by our polynomial and its derivatives. 

```python
def small_roots(f, bounds, m=1, d=None):
	if not d:
		d = f.degree()

	R = f.base_ring()
	N = R.cardinality()
	
	f /= f.coefficients().pop(0)
	f = f.change_ring(ZZ)

	G = Sequence([], f.parent())
	for i in range(m+1):
		base = N^(m-i) * f^i
		for shifts in itertools.product(range(d), repeat=f.nvariables()):
			g = base * prod(map(power, f.variables(), shifts))
			G.append(g)

	B, monomials = G.coefficient_matrix()
	monomials = vector(monomials)

	factors = [monomial(*bounds) for monomial in monomials]
	for i, factor in enumerate(factors):
		B.rescale_col(i, factor)

	B = B.dense_matrix().LLL()

	B = B.change_ring(QQ)
	for i, factor in enumerate(factors):
		B.rescale_col(i, 1/factor)

	H = Sequence([], f.parent().change_ring(QQ))
	for h in filter(None, B*monomials):
		H.append(h)
		I = H.ideal()
		if I.dimension() == -1:
			H.pop()
		elif I.dimension() == 0:
			roots = []
			for root in I.variety(ring=ZZ):
				root = tuple(R(root[var]) for var in f.variables())
				roots.append(root)
			return roots

	return []
```

And finally, the flag!
    
```python
priv = (s1*(k1+x)-z1) * pow(r1, -1, q) % q
print(long_to_bytes(int(priv)))
```