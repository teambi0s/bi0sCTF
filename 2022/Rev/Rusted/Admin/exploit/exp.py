from z3 import *
from gmssl.sm4 import CryptSM4, SM4_ENCRYPT, SM4_DECRYPT

s = Solver()
    
enc = [BitVec(f'enc_{i}', 32) for i in range(8)]

#The rax reg after every subtraction operator should be 0. So basically every subtraction operation was a cmp.
p1 = -0x6C5C0C33 # These 4 bytes are subtracted with enc[0:4], then the difference is added to enc[4..7]
k1 = 0x1337BEEF # This key is used to xor with value in enc[4:8]
x1 = 0x33AEF5CB # Result of k1 XOR enc[4:8]
x2 = 0x550D68CE # Result of enc[8:12] XOR enc[16:20]
x3 = 0x5F9751EB # Result of enc[8:12] XOR enc[12:16]
x4 = 0x4AA34A4 # Result of enc[28:32] XOR enc[20:24]
x5 = 0x2C786553 # Result of enc[28:32] XOR enc[24:28]
x6 = 0x74180051 # Result of enc[8:12] XOR enc[12:16] XOR enc[16:20]
x7 = 0x3E07994C # Result of enc[20:24] XOR enc[28:32] XOR enc[24:28]
s.add(enc[0] - p1 == 0)
s.add(enc[1] - (k1 ^ x1) == 0)
s.add((enc[2] ^ enc[4]) - x2 == 0)
s.add((enc[2] ^ enc[3]) - x3 == 0)
s.add((enc[2] ^ enc[3] ^ enc[4]) - x6 == 0)
s.add((enc[7] ^ enc[5]) - x4 == 0)
s.add((enc[7] ^ enc[6]) - x5 == 0)
s.add((enc[5] ^ enc[6] ^ enc[7]) - x7 == 0)
if s.check() == sat:
    m = s.model()
    cyp = []
    for i in range(8):
        cyp.append(int(str(m[enc[i]])))
else:
    print("Failed !")
enc=b''
for i in range(8):
    enc += cyp[i].to_bytes(4, 'big')
crypt_sm4 = CryptSM4()
key = b"UBHPjBKlsQ2TuNSk"
iv = b"7y0M69TQScm7mfXv"
crypt_sm4.set_key(key, SM4_DECRYPT)
flag = crypt_sm4.crypt_cbc(iv, enc)
print(flag.strip().decode())
