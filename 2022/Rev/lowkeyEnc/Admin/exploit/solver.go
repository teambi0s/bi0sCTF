package main

import (
	"crypto/aes"
	"crypto/cipher"
	"math/rand"
	"fmt"
	"os"
)

type CBC256 struct {
	Key []byte
	IV []byte
}




func (c CBC256) DecryptByCBC(chipherText []byte) []byte { // decrypt the data using AES in CBC mode
	
	decrypted := make([]byte, len(chipherText))

	block, err := aes.NewCipher(c.Key)
	if err != nil {
		panic(err)
	}

	mode := cipher.NewCBCDecrypter(block, c.IV)
	mode.CryptBlocks(decrypted, chipherText[:])

	return decrypted[:len(decrypted)-int(decrypted[len(decrypted)-1])]
}

func main() {
	key := make([]byte, 32)
	iv := make([]byte, 16)
	_, err := rand.Read(key)
	if err != nil {
		panic(err)
	}
	if err != nil {
		panic(err)
	}
	_, err = rand.Read(iv)
	if err != nil {
		panic(err)
	}
	cbc := CBC256{Key: key, IV: iv} // create a new instance of CBC256 with random key and iv generated above 
	enc := []byte{61, 147, 37, 37, 65, 10, 149, 118, 103, 159, 183, 66, 10, 219, 238, 171, 116, 118, 32, 236, 70, 190, 119, 71, 123, 105, 100, 248, 154, 156, 5, 9, 81, 30, 0, 66, 168, 68, 89, 59, 237, 193, 222, 117, 74, 241, 98, 191, 210, 77, 224, 207, 211, 63, 17, 6, 55, 135, 71, 190, 97, 10, 230, 155, 191, 137, 98, 117, 39, 247, 175, 79, 252, 97, 75, 8, 29, 197, 159, 148}
	dec := cbc.DecryptByCBC(enc)
	fmt.Println("Decrypted:", string(dec))	

	
}
