from pwn import *
from sage.all import *
import hashlib
from Crypto.Cipher import AES
import sys
assert(sys.version_info.major >= 3)
import os

e2, e3 = 216, 137
p = 2**e2 * 3**e3 - 1
x = var('x')
F = GF(p**2, 'i', modulus=x**2+1)
i = F.gen()
E0 = EllipticCurve(F, [0,6,0,1,0])

# P2 = E0(204379495676102740041490973468286575535315997318843503224586063562905549024708612587553511338342635086591091176929610745887254412*i + 22872420196504324838979136321638321006997823111154355488586114734767402572165920069051317261695818605731664109366205472735808335147, 7611664238379058654233834889636233025849608286499514963294797909586161580722815842035857355541554277977104603553269124035087010055*i + 6729675657669087698173983489062056565024274909713077675264470640953562104100196655797021963383835150848303171922296928638063659689)
# Q2 = E0(664730098218523292167982363400020395366550164481997346219337637058487742303074645689819403878366058225494657422151471773004501698*i + 24020196275387471060590031678311020195083732081371963590822408444147631516077350271471614656028265177097729060849765057219334904304, 11649302173296077085604661845325264350757157737830169209030878054404098194454456422515874575251024214412297367532176945554081634893*i + 18087286576758701635406671072746164363238669295675802816731454622472294048107318116245801160523339627566482220039919400257186477357)
# P3 = E0(1450751000317567617485006405239600740375658583821733646427744293773583347761404480871340369490616417833721409700683695091102817205*i + 7129368167084706306343966093181450200862088384878736961719406549044964060494661835375265693706216767559310534873530018282409161806, 7508270338265264451596438660168239456976882346086626709392394980287962870582489506520518966125858656954514503641643721616499073943*i + 10278301031007016157464457688982657542899765452290270162017549723416981073359994855570155510691967774601039526814113768611033175046)
# Q3 = E0(7457307432991710874111931785111830749626994006140080535844447954784411921234330826139262171796276164969069344177697208262347496642*i + 4466847147087304651260817927234814729091474044321110091259885535849503956159864374662697511934187216753576889576501318206835242788, 7496003623827874459528670181462877904054393822672687749037460169840526431786002365223496190753030076547096384953477813108186507103*i + 2100333510072338825426353893026019704056966000944157976148445749588704795284466888153733993807415347958289632269707592438832676438)

def parse_field_element(s):
    s = s.replace(' ', '')  
    if '+' in s or '-' in s[1:]:  
        parts = s.replace('+', ' + ').replace('-', ' - ').split()
        re_part = parts[2] 
        im_part = parts[0].replace('*i', '')
        if im_part.startswith('+'):
            im_part = im_part[1:]
        elif im_part == '-':
            im_part = '-1'
        elif im_part == '':
            im_part = '1'
    else:
        if '*i' in s:
            re_part = '0'
            im_part = s.replace('*i', '')
            if im_part == '' or im_part == '+':
                im_part = '1'
            elif im_part == '-':
                im_part = '-1'
        else:
            re_part = s
            im_part = '0'
    re = ZZ(re_part)
    im = ZZ(im_part)
    return F(re + im * i)

def parse_invariants_tuple(s):
    s = s.strip('()')
    elements = s.split(',')
    return [parse_field_element(elem.strip()) for elem in elements]

def read_pub_key():
    
    r.readuntil("PA: ")
    P_2_str = r.readline().strip().decode('ascii')
    P_2 = parse_invariants_tuple(P_2_str)  
    P2 = E0((P_2[0], P_2[1]))
    print("P_A = ", P2)
    
    r.readuntil("QA: ")
    Q_2_str = r.readline().strip().decode('ascii')
    Q_2 = parse_invariants_tuple(Q_2_str) 
    Q2 = E0(Q_2[0], Q_2[1])
    print("Q_A = ", Q2)
    
    r.readuntil("PB: ")
    P_3_str = r.readline().strip().decode('ascii')
    P_3 = parse_invariants_tuple(P_3_str)  
    P3 = E0(P_3[0], P_3[1])
    print("P_B = ", P3)
    
    r.readuntil("QB: ")
    Q_3_str = r.readline().strip().decode('ascii')
    Q_3 = parse_invariants_tuple(Q_3_str) 
    Q3 = E0(Q_3[0], Q_3[1])
    print("Q_B = ", Q3)
    
    r.readuntil("EA invariants: ")
    E_A_str = r.readline().strip().decode('ascii')
    E_A_invariants = parse_invariants_tuple(E_A_str)  
    E_A = EllipticCurve(F, E_A_invariants)
    print("E_A = ", E_A_invariants)
    
    r.readuntil("φAPB: ")
    φAPB_str = r.readline().strip().decode('ascii')
    A_P_B = parse_invariants_tuple(φAPB_str)  
    φAPB = E_A(A_P_B[0], A_P_B[1])
    # print("φAPB:", φAPB)
    
    r.readuntil("φAQB: ")
    φAQB_str = r.readline().strip().decode('ascii')
    A_Q_B = parse_invariants_tuple(φAQB_str)  
    φAQB = E_A(A_Q_B[0], A_Q_B[1])
    # print("φAQB:", φAQB)
    
    r.readuntil("φAPA: ")
    φAPA_str = r.readline().strip().decode('ascii')
    print("A_P_A =", φAPA_str)
    A_P_A = parse_invariants_tuple(φAPA_str) 
    φAPA = E_A(A_P_A[0], A_P_A[1])
    # print("φAPA:", φAPA)
    
    r.readuntil("φAQA: ")
    φAQA_str = r.readline().strip().decode('ascii')
    print("A_Q_A =", φAQA_str)
    A_Q_A = parse_invariants_tuple(φAQA_str)  
    φAQA = E_A(A_Q_A[0], A_Q_A[1])
    # print("φAQA:", φAQA)
        
    r.readuntil("EB invariants: ")
    E_B_str = r.readline().strip().decode('ascii')
    E_B_invariants = parse_invariants_tuple(E_B_str)  
    E_B = EllipticCurve(F, E_B_invariants)
    # print("E_B invariants:", E_B_invariants)

    r.readuntil("φBPA: ")
    φBPA_str = r.readline().strip().decode('ascii')
    B_P_A = parse_invariants_tuple(φBPA_str) 
    φBPA = E_B(B_P_A[0], B_P_A[1])
    # print("φBPA:", φBPA)

    r.readuntil("φBQA: ")
    φBQA_str = r.readline().strip().decode('ascii')
    B_Q_A = parse_invariants_tuple(φBQA_str)  
    φBQA = E_B(B_Q_A[0], B_Q_A[1])
    # print("φBQA:", φBQA)
    
    r.readuntil("IV1: ")
    iv1 = bytes.fromhex(r.readline().strip().decode('ascii'))
    # print("IV1:", iv1.hex())

    r.readuntil("CT1: ")
    ct1 = bytes.fromhex(r.readline().strip().decode('ascii'))
    # print("CT2:", ct1.hex())

    r.readuntil("IV2: ")
    iv2 = bytes.fromhex(r.readline().strip().decode('ascii'))
    # print("IV2:", iv2.hex())

    r.readuntil("CT2: ")
    ct2 = bytes.fromhex(r.readline().strip().decode('ascii'))
    # print("CT2:", ct2.hex())

    return (P2, Q2, P3, Q3, E_A, φAPB, φAQB, φAPA, φAQA, E_B, φBPA, φBQA, iv1, ct1, iv2, ct2)

def isogen2(sk2):
    Ei = E0
    P = P3
    Q = Q3
    S = P2+sk2*Q2
    for i in range(e2):
        phi = Ei.isogeny((2**(e2-i-1))*S)
        Ei = phi.codomain()
        S = phi(S)
        P = phi(P)
        Q = phi(Q)
    return (Ei,P,Q)

def isoex2(sk2, pk3):
    Ei, P, Q = pk3
    S = P+sk2*Q
    for i in range(e2):
        R = (2**(e2-i-1))*S
        phi = Ei.isogeny(R)
        Ei = phi.codomain()
        S = phi(S)
    return Ei

def isogen3(sk3):
    Ei = E0
    P = P2
    Q = Q2
    S = P3+sk3*Q3
    for i in range(e3):
        phi = Ei.isogeny((3**(e3-i-1))*S)
        Ei = phi.codomain()
        S = phi(S)
        P = phi(P)
        Q = phi(Q)
    return (Ei,P,Q)

def elem_to_coefficients(x):
    l = x.polynomial().list()
    l += [0]*(2-len(l))
    return l

def send_public_key(E, phiP, phiQ):
    print("sending public key...")
    for tup in map(elem_to_coefficients, [E.a1(),E.a2(),E.a3(),E.a4(),E.a6()]):
        r.readuntil('re: ')
        r.sendline(str(tup[0]))
        r.readuntil('im: ')
        r.sendline(str(tup[1]))
    r.readuntil('re: ') #Px
    r.sendline(str(elem_to_coefficients(phiP[0])[0]))
    r.readuntil('im: ')
    r.sendline(str(elem_to_coefficients(phiP[0])[1]))
    r.readuntil('re: ') #Py
    r.sendline(str(elem_to_coefficients(phiP[1])[0]))
    r.readuntil('im: ')
    r.sendline(str(elem_to_coefficients(phiP[1])[1]))
    r.readuntil('re: ') #Qx
    r.sendline(str(elem_to_coefficients(phiQ[0])[0]))
    r.readuntil('im: ')
    r.sendline(str(elem_to_coefficients(phiQ[0])[1]))
    r.readuntil('re: ') #Qy
    r.sendline(str(elem_to_coefficients(phiQ[1])[0]))
    r.readuntil('im: ')
    r.sendline(str(elem_to_coefficients(phiQ[1])[1]))

def aes_cbc_encrypt(key, pt):
    iv = os.urandom(16)
    c  = AES.new(key, AES.MODE_CBC, iv)
    return iv, c.encrypt(pt)


def oracle(EA, phiAPB, phiAQB, EAB, pt):
    send_public_key(EA, phiAPB, phiAQB)
    shared = EAB.j_invariant()

    key = hashlib.sha256(str(shared).encode()).digest()[:16]
    iv, ct = aes_cbc_encrypt(key, pt)
    r.clean()
    r.sendline(iv.hex())
    r.sendline(ct.hex())
    ans = r.recvline().strip()
    print('ORACLE:', ans)
    if  b"Good!" in ans:
        return True
    elif b"Bad!" in ans:
        return False
    else:
        assert False, "Oracle response unknown"
        

## GPST attack, assumes sk has shape (1, alpha)
def attack(eA, eB, E0, PA, QA, PB, QB, EB, phiBPA, phiBQA, flag1):
    # PA,QA,PB,QB are not used besides key generation
    print("starting attack...")
    load("./sqrts.sage") # load square roots because sage fails to compute them
    K = Integer(0)

    print('KeyGen...')
    skA = randint(1,2**eA-1)
    EA, phiAPB, phiAQB = isogen2(skA)
    # tests done by the server:
    assert(phiAPB*(3**eB) == EA(0) and phiAPB*(3**(eB-1)) != EA(0))
    assert(phiAQB*(3**eB) == EA(0) and phiAQB*(3**(eB-1)) != EA(0))
    assert(phiAPB.weil_pairing(phiAQB, Integer(3**eB)) == (PB.weil_pairing(QB, Integer(3**eB)))**Integer(2**eA))
    EAB = isoex2(skA, (EB,phiBPA,phiBQA)) # (sk2,pk3)
    print('...done')

    for i in range(eB - 3):
        print('\n===  i =', i,' / ', eB-3, '  ===')
        alpha = 0
        theta = sqrts[i]

        # computing next bit (like if attacking Alice)
        #R_ = theta * (phiAPB - (2**(eA - i - 1) * K) * phiAQB)
        #S_ = theta * (1 + 2**(eA - i - 1)) * phiAQB
        #o = oracle(EA, R_, S_, EAB)
        #if not o:
        #    K += alpha*2**i
        #print("--- current :", bin(K))

        for x in range(2): # computing a trit (Bob's key), cycle to l-1
            R_ = theta * (phiAPB - (3**(eB - i - 1) * (K+(x*3**i))) * phiAQB)
            S_ = theta * (1 + 3**(eB - i - 1)) * phiAQB
            o = oracle(EA, R_, S_, EAB, flag1)
            if o:
                K += x*3**i
                break
        if not o:
            K += 2*(3**i) # if trit is not {0,1} then it's 2

        print("---------current----------:\n",\
              K.str(base=3),\
              "\n---------------------------")

    ## bruteforcing the rest of the key
    print("bruteforcing last trits...")
    for i in range(3):
        for j in range(3):
            for k in range(3):
               print("===  i,j,k: ", (i,j,k), "  ===")
               K_ = K
               K_ += i*3**(eB-1) + j*3**(eB-2) + k*3**(eB-3)
               EB_, _, _ = isogen3(K_)
               if EB_.j_invariant() == EB.j_invariant():
                   solution = K_ % 3**eB
                   return solution

    print("FAILED:", K)
    return "Key not found"

def comp_iso(E, Ss, ℓ, e):
    φ,  E1 = None, E
    for k in range(e):
        R = [ℓ**(e-k-1) * S for S in Ss]
        ϕk = E1.isogeny(kernel=R)
        Ss = [ϕk(S) for S in Ss]
        E1 = ϕk.codomain()
        φ  = ϕk if φ is None else ϕk * φ
    return φ, E1

def j_ex(E, sk, pk, ℓ, e):
    φ, _ = comp_iso(E, [pk[0] + sk*pk[1]], ℓ, e)
    return φ.codomain().j_invariant()

def aes_cbc_decrypt(key, iv, ct):
    c  = AES.new(key, AES.MODE_CBC, iv)
    return c.decrypt(ct)

if __name__ == "__main__":
    local = False
    if local:
        r = process(['sage','./chall.sage'])
        # goal = Integer(r.readline().decode('ascii').strip().split(' ')[-1])
        # print("GOAL:", goal.str(base=3), goal.str())    
    else:
        IP = 'localhost'
        PORT = 5000
        r = remote(IP, PORT)
    
    P2, Q2, P3, Q3, E_A, A_P_B, A_Q_B, A_P_A, A_Q_A, E_B, B_P_A, B_Q_A, iv1, ct1, iv2, ct2 = read_pub_key()
    x = 1
    a = A_Q_A
    b = E_A(0)-x*A_P_A
    # y = discrete_log(b, a, ord=2^216, operation="+")
    y = int(input("input y: "))
    j1 = j_ex(E0, y, (P3,Q3), 3, e3)
    flag1 = aes_cbc_decrypt(hashlib.sha256(str(j1).encode()).digest()[:16], iv1, ct1)
    print("flag1:", flag1)
    alpha_ = attack(e2, e3, E0, P2, Q2, P3, Q3, E_B, B_P_A, B_Q_A, flag1) 
    assert alpha_ != "Key not found", "Failed to compute secret key"
    print("===== found secretkey:", alpha_, "=====")
    j2 = j_ex(E0, alpha_, (P2,Q2), 2, e2)
    flag2 = aes_cbc_decrypt(hashlib.sha256(str(j2).encode()).digest()[:16], iv2, ct2)
    print("flag2:", flag2)
    r.close()
    if local:
        print("local mode, press any key to exit")
        input()
    else:
        r.close()
        