from pwn import remote, context
import json
from tqdm import trange

con = remote("localhost", 5000)
# context.log_level = "debug"

def xor(a, b):
    return bytes([x^y for x,y in zip(a,b)])

def oracle(ct, iv1, iv2):
    token = json.dumps({"ciphertext": ct.hex(), "IV1": iv1.hex(), "IV2": iv2.hex()}).encode()
    con.sendlineafter(b"Enter token: ", token)
    con.recvuntil(b"Decryption result: ")
    check = json.loads(con.recvline().strip().decode())["result"]
    if check == "Valid padding":
        return True
    return False

BLOCK_SIZE = 16
def single_block_attack(block, iv2):
    zeroing_iv = [0] * BLOCK_SIZE

    for pad_val in range(1, BLOCK_SIZE+1):
        padding_iv = [pad_val ^ b for b in zeroing_iv]

        for candidate in trange(256, desc=f"Padding {pad_val}"):
            padding_iv[-pad_val] = candidate
            iv1 = bytes(padding_iv)
            if oracle(block, iv1, iv2):
                if pad_val == 1:
                    padding_iv[-2] ^= 1
                    iv1 = bytes(padding_iv)
                    if not oracle(block, iv1, iv2):
                        continue
                break
        zeroing_iv[-pad_val] = candidate ^ pad_val

    return zeroing_iv

def full_attack(ct, iv1, iv2):
    blocks = [ct[i:i+BLOCK_SIZE] for i in range(0, len(ct), BLOCK_SIZE)]
    result = b''

    block_iv1, block_iv2 = iv1, iv2
    for ct in blocks:
        dec = single_block_attack(xor(ct, block_iv2), b"\x00"*16)
        pt = xor(block_iv1, dec)
        block_iv1 = xor(ct, block_iv2)
        block_iv2 = dec
        result += pt
        print(result)
    return result

con.recvuntil(b"Here is the encrypted message : ")
token = json.loads(con.recvline().decode())
iv1 = bytes.fromhex(token["IV1"])
iv2 = bytes.fromhex(token["IV2"])
ct = bytes.fromhex(token["ciphertext"])
print(full_attack(ct, iv1, iv2))
