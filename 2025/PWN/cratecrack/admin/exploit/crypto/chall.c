#pragma once
#include <secp256k1.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <openssl/sha.h>
#include <stdint.h>
#include <openssl/evp.h>
#include "./tallocator.c"

#define FLAG "CTF{sample_flag_here}"
#define MSG1 "Lord, grant me the strength to accept the things I cannot change; Courage to change the things I can; And wisdom to know the difference."
#define MSG2 "Wherever There Is Light, There Are Always Shadows"

static bool already_called = false;

static int custom_nonce_function(
    unsigned char *nonce32,
    const unsigned char *msg32,
    const unsigned char *key32,
    const unsigned char *algo16,
    void *data,
    unsigned int attempt)
{
    memcpy(nonce32, key32, 16);
    memcpy(nonce32 + 16, msg32, 16);
    return 1;
}

void derive_key(uint8_t key[16], const uint8_t privkey[32])
{
    uint8_t hash[32];
    SHA256(privkey, 32, hash);
    memcpy(key, hash, 16);
}

void aes_encrypt(const uint8_t key[16], const uint8_t *plaintext, size_t len,
                 uint8_t *iv, uint8_t *ciphertext, int *out_len)
{
    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
    int len_tmp;

    EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, key, iv);
    EVP_CIPHER_CTX_set_padding(ctx, 1);

    EVP_EncryptUpdate(ctx, ciphertext, &len_tmp, plaintext, len);
    *out_len = len_tmp;

    EVP_EncryptFinal_ex(ctx, ciphertext + len_tmp, &len_tmp);
    *out_len += len_tmp;

    EVP_CIPHER_CTX_free(ctx);
}

size_t pkcs7_pad(uint8_t *output, const uint8_t *input, size_t len, size_t block_size)
{
    size_t pad_len = block_size - (len % block_size);
    memcpy(output, input, len);
    for (size_t i = 0; i < pad_len; ++i)
    {
        output[len + i] = (uint8_t)pad_len;
    }
    return len + pad_len;
}

int trigger_encryption()
{
    if(already_called){
        return 0;
    }
    already_called = true;
    secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);
    secp256k1_ecdsa_signature sig1, sig2;
    void* copy_sig1, *copy_sig2, *copy_enc_flag, *copy_pub_key;

    unsigned char privkey[32];
    FILE *urandom = fopen("/dev/urandom", "rb");
    fread(privkey, 1, 32, urandom);
    fclose(urandom);

    unsigned char hash1[32], hash2[32];
    SHA256((unsigned char *)MSG1, strlen(MSG1), hash1);
    SHA256((unsigned char *)MSG2, strlen(MSG2), hash2);

    if (!secp256k1_ecdsa_sign(ctx, &sig1, hash1, privkey, custom_nonce_function, NULL))
    {
        exit(1);
    }

    if (!secp256k1_ecdsa_sign(ctx, &sig2, hash2, privkey, custom_nonce_function, NULL))
    {
        exit(1);
    }

    unsigned char sig[64];
    secp256k1_ecdsa_signature_serialize_compact(ctx, sig, &sig1);
    secp256k1_ecdsa_signature_serialize_compact(ctx, sig, &sig2);

    secp256k1_pubkey pubkey;
    if (!secp256k1_ec_pubkey_create(ctx, &pubkey, privkey))
    {
        exit(1);
    }

    if (!secp256k1_ecdsa_verify(ctx, &sig1, hash1, &pubkey))
    {
        exit(1);
    }

    if (!secp256k1_ecdsa_verify(ctx, &sig2, hash2, &pubkey))
    {
        exit(1);
    }

    uint8_t padded_flag[64];
    size_t flag_len = strlen(FLAG);
    size_t padded_len = pkcs7_pad(padded_flag, (const uint8_t *)FLAG, flag_len, 16);

    uint8_t key[16], iv[16], ciphertext[64] = {0};
    memcpy(iv, privkey, 16);
    derive_key(key, privkey);
    int enc_len;
    aes_encrypt(key, padded_flag, padded_len, iv, ciphertext, &enc_len);
    
    unsigned char pubkey_bytes[65];
    size_t pubkey_len = sizeof(pubkey_bytes);
    secp256k1_ec_pubkey_serialize(ctx, pubkey_bytes, &pubkey_len, &pubkey, SECP256K1_EC_UNCOMPRESSED);

    copy_sig1 = talloc(sizeof(sig1), (char *)&sig1);
    copy_sig2 = talloc(sizeof(sig2), (char *)&sig2);
    copy_enc_flag = talloc(padded_len, (char *)&ciphertext);
    copy_pub_key = talloc(pubkey_len, (char*)&pubkey);
    secp256k1_context_destroy(ctx);
    return 0;
}
