import gmpy2
from fastecdsa.curve import secp256k1
from fastecdsa.point import Point
from itertools import product
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.number import long_to_bytes, bytes_to_long

class ECDSAAttacker:
    def __init__(self):
        self.mask_lsb = (1 << 128) - 1
        self.mask_msb = (1 << 256) - 1
    
    def recover_key_msb(self, hashes, signatures_s, signatures_r, public_key):
        h1, h2 = hashes
        s1, s2 = signatures_s
        r1, r2 = signatures_r
        
        s1_inv = gmpy2.invert(s1, secp256k1.q)
        s2_inv = gmpy2.invert(s2, secp256k1.q)
        
        h1_lsb = h1 >> 128
        h2_lsb = h2 >> 128
        
        signs = product([-1, 1], repeat=2)
        
        try:
            a_inv = gmpy2.invert(r1 * s1_inv - r2 * s2_inv, secp256k1.q)
            b = h1 * s1_inv - h2 * s2_inv
            
            for sign1, sign2 in signs:
                # Calculate the private key candidate
                c = sign1 * h1_lsb - sign2 * h2_lsb
                d = ((c - b) * a_inv) % secp256k1.q
                
                # Verify if this is the correct private key
                if int(d) * secp256k1.G == public_key:
                    return d
                    
        except (ValueError, ZeroDivisionError):
            # If the denominator is zero, try a different approach
            pass
        
        return None
    
    def recover_key_lsb(self, hashes, signatures_s, signatures_r, public_key):
        """
        Recover private key from signatures using LSB half-half attack
        """
        h1, h2 = hashes
        s1, s2 = signatures_s
        r1, r2 = signatures_r
        
        # Calculate modular inverses
        s1_inv = gmpy2.invert(s1, secp256k1.q)
        s2_inv = gmpy2.invert(s2, secp256k1.q)
        
        # Extract MSB parts (these are the parts used in LSB nonce generation)
        h1_msb = h1 & self.mask_lsb
        h2_msb = h2 & self.mask_lsb
        
        # Test all possible sign combinations
        signs = product([-1, 1], repeat=2)
        
        try:
            a_inv = gmpy2.invert(r1 * s1_inv - r2 * s2_inv, secp256k1.q)
            b = h1 * s1_inv - h2 * s2_inv
            
            for sign1, sign2 in signs:
                c = (sign1 * h1_msb - sign2 * h2_msb) << 128
                d = ((c - b) * a_inv) % secp256k1.q
                
                if int(d) * secp256k1.G == public_key:
                    return d
                    
        except (ValueError, ZeroDivisionError):
            pass
        
        return None
    
    def solve_challenge(self):
        sig1 = "39c87b06bd05c22fbe1cf1ee59dccaf195f56c936ae667e0f4b1643d939c1c884c6083edd014c12c3cbf503e2040b460e57ff4a615913419c18f5bf42d26ce9d"
        r1, s1 = int(sig1[:64], 16), int(sig1[64:], 16)
        sig2 = "7da1993ed0aeee33f2a55bdd4a5fb553478cb687ad1c96b118ad035967644cea2f1129747bd57f446abd4128be14debbddd5d8d5762341890f6e1d6f24980620"
        r2, s2 = int(sig2[:64], 16), int(sig2[64:], 16)

        # Extract public key
        pub_hex = "044c7c4ead18a412697418bf010bc9a7aa6885a29342a7ebd727bc28dac6aaa64958793458fa07e44135ff0a17d276613a53e7b4ea3ab097c51478273fd1cefaa2"
        pub_x = int(pub_hex[2:66], 16)
        pub_y = int(pub_hex[66:], 16)
        public_key = Point(pub_x, pub_y, secp256k1)
        
        m1 = b"Lord, grant me the strength to accept the things I cannot change; Courage to change the things I can; And wisdom to know the difference."
        m2 = b"Wherever There Is Light, There Are Always Shadows"
        
        h1 = int.from_bytes(hashlib.sha256(m1).digest(), "big")
        h2 = int.from_bytes(hashlib.sha256(m2).digest(), "big")
        
        print(f"Public key: ({hex(pub_x)}, {hex(pub_y)})")
        print(f"Hash 1: {hex(h1)}")
        print(f"Hash 2: {hex(h2)}")
        print(f"Signature 1: (r={hex(r1)}, s={hex(s1)})")
        print(f"Signature 2: (r={hex(r2)}, s={hex(s2)})")
        print()
        
        # Try MSB attack first
        print("Trying MSB half-half attack...")
        private_key = self.recover_key_msb([h1, h2], [s1, s2], [r1, r2], public_key)
        
        if private_key:
            print(f"SUCCESS! Private key recovered using MSB attack: {hex(private_key)}")
            return private_key
        
        # Try LSB attack if MSB fails
        print("MSB attack failed, trying LSB half-half attack...")
        private_key = self.recover_key_lsb([h1, h2], [s1, s2], [r1, r2], public_key)
        
        if private_key:
            print(f"SUCCESS! Private key recovered using LSB attack: {hex(private_key)}")
            return private_key
        
        print("FAILED: Could not recover private key with either attack method")
        return None

def main():
    attacker = ECDSAAttacker()
    
    # try:
    private_key = attacker.solve_challenge()
    
    if private_key:
        IV = long_to_bytes(private_key)[:16]
        key = hashlib.sha256(long_to_bytes(private_key)).digest()[:16]
        cipher = AES.new(key, AES.MODE_CBC, iv = IV)
        flag = cipher.decrypt(bytes.fromhex("28c463198dc29bb23ed9818f78b187871ed671e2c9483acacc2d0a0eaf0972a2"))
        print(flag)
            
    # except Exception as e:
    #     print(f"Error: {e}")

if __name__ == "__main__":
    main()
